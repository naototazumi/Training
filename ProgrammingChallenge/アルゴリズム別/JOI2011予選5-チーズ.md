https://atcoder.jp/contests/joi2011yo/tasks/joi2011yo_e
![image](https://user-images.githubusercontent.com/46245101/113536035-0a37bc00-9610-11eb-824d-441bc8735525.png)
![image](https://user-images.githubusercontent.com/46245101/113536052-13c12400-9610-11eb-9a16-831100c5fa76.png)


```
#include <bits/stdc++.h>
#define REP(i, n) for (int i = 0; (i) < (int)(n); ++ (i))
#define REP3(i, m, n) for (int i = (m); (i) < (int)(n); ++ (i))
#define REP_R(i, n) for (int i = (int)(n) - 1; (i) >= 0; -- (i))
#define REP3R(i, m, n) for (int i = (int)(n) - 1; (i) >= (int)(m); -- (i))
#define ALL(x) std::begin(x), std::end(x)
#define E 2.71828182845904523536
using namespace std;
using ll = long long;
ll h, w, n, inf=1<<30, cnt=0, sy, sx, gy, gx, y, x, nowy, nowx, ans=0;
vector<vector<ll>> Map, Map_orig;
vector<pair<ll,ll>> C;
vector<ll> dy = {0,1,-1,0};
vector<ll> dx = {-1,0,0,1};

ll bfs(queue<pair<ll,ll>> q) {
  while(!q.empty()){
    pair<ll, ll> now;
    now = q.front(); q.pop();
    nowy = now.first; nowx= now.second;
    REP(i,4) {
      y = nowy+dy[i]; x = nowx+dx[i];
      if(y>=0 && y<h && x>=0 && x<w) {
        if(Map[y][x]==inf) {
          Map[y][x] = Map[nowy][nowx] + 1;
          q.push(make_pair(y, x));
        }
      }
    }
    if(Map[gy][gx]!=inf) return Map[gy][gx];
  }
}

int main() {
  ios::sync_with_stdio(false);
  cin.tie(nullptr);
  constexpr char endl = '\n';

  // input
  cin >> h >> w >> n;
  Map = vector<vector<ll>>(h, vector<ll>(w, -1));
  C = vector<pair<ll,ll>>(n+1);
  string tmp;
  REP(i, h) {
    cin >> tmp;
    REP(j ,w) {
      if(tmp[j]!='X') Map[i][j] = inf;
      if(tmp[j]=='S') C[0]=make_pair(i, j);
      else if(tmp[j]!='X' && tmp[j]!='.') C[tmp[j]-'0']=make_pair(i, j);
    }
  }
  Map_orig = Map;
  REP(i,n){
    queue<pair<ll,ll>> q;
    Map = Map_orig;
    sy=C[i].first; sx=C[i].second; gy=C[i+1].first; gx=C[i+1].second;
    Map[sy][sx] = 0;
    REP(i,4) {
      y = sy+dy[i]; x = sx+dx[i];
      if(y>=0 && y<h && x>=0 && x<w) {
        if(Map[y][x]==inf) {
          Map[y][x] = 1;
          q.push(make_pair(y, x));
        }
      }
    }
    ans += bfs(q);
  }
  // output
  cout << ans << '\n';
}
```

